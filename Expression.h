#pragma once
#include <iostream>
#include <vector>
#include <map>

using namespace std;

inline void ExprTest();
inline void ExprCycle();

class SomeClass
{
	//int _i; Даже если убрать эту переменную, то ничего не изменится в поведении класса при перемещении.
public:
	SomeClass() = default; // То же самое, что {}.
	SomeClass(const SomeClass&)
	{
		cout << "Copy ctor called.\n";
	}

	SomeClass(SomeClass&&) noexcept
	{
		try
		{
			cout << "Move ctor called.\n";
		}
		catch (...)
		{

		}
	}
};

inline SomeClass MeReturn() // Конструктор копирования НЕ будет вызван.
{
	return SomeClass{}; // Копирование и перемещение будет пропущено. То же самое, что ().
}

/*inline SomeClass MeReturn() // Конструктор копирования будет вызван.
{
	SomeClass some{};
	return some;
}*/

/*inline SomeClass MeReturn() // Конструктор копирования будет вызван.
{
	SomeClass some{};
	if (false)
		return SomeClass{};
	return some;
}*/

inline void _stdcall GetFunc(int a, int b)
{

}

inline void MeAccept([[maybe_unused]] SomeClass s)
{

}

class SomeClass1
{
	friend int operator<<(const SomeClass1& obj, int&);

public:
	explicit SomeClass1(const int var) : _mVar{ var }
	{

	}

private:
	int _mVar;
};

inline int operator<<(const SomeClass1& obj, int& shift)
{
	return obj._mVar << shift;
}

template < class T > class B {};

class A
{
public:
	A& operator, (int index)
	{
		cout << "A::" << typeid(index).name() << " = " << index << endl;
		return *this;
	}

	template<typename T> A& operator, (const B<T>& b)
	{
		cout << typeid(b).name() << endl;
		return *this;
	}
};

class Class
{
	int t, *r;
public:
	//Class() = default; // Такая запись означает то же самое, что полное отсутствие конструкторов.
	Class() {	} // В этом случае ни в одном инициализаторе t НЕ будет инициализирована, т.к. она не инициализирована в конструкторе.
};

struct TetStr
{
	int a = 13;
	double b = 20.2;
};

inline decltype(auto) Func()
{
	return 0.0L;
}

inline auto Funt() -> int
{
	return 0;
}

template<typename T, typename U> struct S
{
	T m_first;
	U m_second;
	S(T first, U second) : m_first(first), m_second(second) {}
};

inline void TestExpression()
{
	ExprTest();
	ExprCycle();

	[[maybe_unused]] S s2 = { 10, 'c' };

	const TetStr tst{};
	auto[a, bc] = tst;
	a = 12; // a и b не являются ссылками, а являются копиями.
	bc = 19.9;
	// auto&[a1, bc1] = tst; // Так нельзя писать.

	vector<int> vct = { 1, 2, 3 };

	decltype(auto) r = vct.emplace_back(10);
	r = 43;

	for (const auto &i : vct)
	{
		std::cout << i << ' ';
	}

	map<int, char> myMap;

	for (const auto &[key, value] : myMap)
	{
		std::cout << "key: " << key << ' ';
		std::cout << "value: " << value << '\n';
	}

	Class c{}; // t не публичная, поэтому она не отобразится. t БУДЕТ инициализирована. Если есть конструктор по умолчанию, то он будет вызван, но при этом t не будет инициализирована, если она в нём не прописана.
	Class d; // t НЕ БУДЕТ инициализирована. Если есть конструктор по умолчанию, то он будет вызван, но при этом t не будет инициализирована. Если его нет, то t НЕ будет инициализирована.
	Class j = Class(); // t БУДЕТ инициализирована. При этом нельзя написать: Class j(). В этом случае результат неизвестен. Если есть конструктор по умолчанию, то он будет вызван, но при этом t не будет инициализирована.

	int i1 = 1;
	// ReSharper disable once CppAssignedValueIsNeverUsed
	i1 = i1++ + i1++; // Вначале происходит сложение переменной самой с собой.
	//Этот код уходит "вникуда", т.е. он сохраняет результат как значение переменной "i1" во временную переменную, затем берёт из "i1" значение и сохраняет его в неё же, увеличив на один, затем делает это же второй раз, получая значение два, после этого это значение затирается из временной переменной.
	//Значение временной переменной и есть итоговый результат.
	//Если значение переменной i1 изначально было ноль, то она и будет ноль в итоге.
	//Если изначально была единица, то будет два.

	int value = 0;
	(cout << "first\n", value++) && (cout << "second\n", value++);
	GetFunc(value++, value++);

	// ReSharper disable once CppDeclaratorNeverUsed
	auto some = MeReturn();
	MeAccept(some);// Если написать some, то конструктор копирования будет вызван, если SomeClass{} - нет.

	int mas[3], i = 0;
	mas[i++] = i++; // Сначала берёт значение i (в конце), затем увеличивает его, запоминая старое. Далее запоминается старое значение в операторе [] и происходит инкремент. Таким образом, получается, что элементу с индексом 1 будет присвоено значение 0. i будет равна 2.

	value = i = 0;
	int p = (i = 1) << (value = 2); // = 4.

	//Первый результат гарантировано будет 4, тогда как второй может быть как 2, так и 4. Этот пример хорошо показывает разницу между явным и неявным вызовом перегруженного оператора в C++17.
	i = 0;
	int result = SomeClass1{ i = 1 } << (i = 2);
	cout << "First result: " << result << "\n";
	result = operator<<(SomeClass1{ i = 1 }, i = 2); // Сначала выполняется i = 2, затем i = 1. В конструктор подастся единица. result будет равен двум.
	cout << "Second result: " << result << "\n";

	/*for (int k = 0;
		(k = 9, k = 8) >= 0; // Сначала выполняется k = 9, потом k = 8.
		k++);*/ // Если раскомментить, то зависнет.

	const B<double> b;
	A(), 1, b; // Сначала A::int, затем B, т.е. выражение (A(), 1) берёт аргумент b.
	A(), b, 1; // Работает в обратном порядке.

	i = 1'000; // 1000.
}

inline void ExprTest()
{
	int a[] = { 1, 2, 3, 4, 5, 6 };
	const int a2 = 3[a - 1] - a[3] + (a - 1)[5]; // (3 - 4) + 5 = 4;
	const int a3 = a[2] - a[3] + a[4]; // То же самое.
	cout << "a2 = " << a2 << "; a3 = " << a3 << endl;

	char str[6] = "emacs"; // str[5] написать нельзя.
	cout << str << endl;

	// Инициализируются ли массивы? Какой тип индекса массива?

	// int a <::> = <%1, 2, 3, 4, 5, 6%>; // Не скомпилируется.
}

inline void ExprCycle()
{
	[[maybe_unused]] const auto t = 25u - 50; // Тип unsigned int.
	[[maybe_unused]] const auto y = 25 - 50u; // Тип unsigned int.
	[[maybe_unused]] const auto w = -25 - 50u; // Тип unsigned int.
	[[maybe_unused]] const auto z = 25u - -50; // Тип unsigned int.
	[[maybe_unused]] const auto p = 3.14 - 3.14f; // Тип double.
	[[maybe_unused]] const auto d = 3.14f - 3.14; // Тип double.
	[[maybe_unused]] const auto h = 0xFFFFFFFF; // 0xFFFFFFFF - unsigned int; 0xFF - signed int.
	[[maybe_unused]] const auto j = 4294967295; // unsigned long.
	[[maybe_unused]] const auto s = 429496729;  // int.
	[[maybe_unused]] const auto a = 0xFFFFFFFFFFFFFFFF; // unsigned long long.
	[[maybe_unused]] const auto q = 0xFFFFFFFF - 1; // unsigned int.
	[[maybe_unused]] const auto v = 0xFFFFFFFF + 1; // unsigned int.
	// [[maybe_unused]] const auto b = 0x10000000000000000; // Слишком большое значение.

	const char ch = 1;
	[[maybe_unused]] auto fg = ch * 2; // int. Даже, если написать (char).
	[[maybe_unused]] auto fq = 2 * ch; // int. Даже, если написать (char).

	/*unsigned char half_limit = 150; // ЗАВИСАНИЕ.
	for (unsigned char i = 0; i < 2 * half_limit; ++i)
	{
		//что-то происходит;
	}*/
}