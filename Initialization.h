#pragma once

class MassiveInit
{
	double ui;
	int mas[2];

public:
	int i;
	float flt;

	MassiveInit() : i()
	{

	}
};

class MassiveInit1
{
	double ui;
	float flt;

public:
	int i = 90;
	float rt;
	int mas[2];
};

class Massive
{
	void vd() {}
	int u;
public:
	int at;

	Massive()
	{

	}
};

class MasHolder
{
public:
	Massive mas;
	int tt;
};

class BN
{
public:
	BN(int, float) {}
	int op;
};

class Book
{
public:
	BN mas; // (10, 1) - инициализировать нельзя.
	int yu;
};

class BCInh : public BN
{
public:
	BCInh() : BN(10, 90.9f)
	{

	}

	int t;
};

inline void FuncTry() noexcept try // МОЖНО ПИСАТЬ ТАК.
{

}
catch (...) {}

inline int Mas1[2]; // Нужен inline. Будет инициализирован.
static int Mas2[2]; // Будет инициализирован.

class DF
{
	int i = 9;
public:
	void Void()
	{
		if (this == nullptr) // this не проверяется на nullptr.
			return;
		i = 90;
	}
};

class DG
{
public:
	int t;
public:
	//DG(float) : t(0){}
};

class DS
{
	int t, u, t1;
public:
	DS(float f, int u) : t(f), u(u) {}
	// DS() = default;
};

class IniSeq
{
	Massive mas; DS ds;
	MassiveInit ms;
	BCInh bci;
	int i;
	double d;

public:
	IniSeq() : d(10.1), i(5), ds(11.4, 56)
	{
		// Инициализация будет проходить в порядке написания элементов в классе: mas, ds, ms, bci, i, d.
	}
};

class DoubleInit
{
	int i = 19;

public:
	DoubleInit() :i(20)
	{

	}

	DoubleInit(float) : i(30)
	{

	}
};

inline void MasInitDemo()
{
	FuncTry();

	MasHolder masHolder = { Massive{}, 89 }; // У Massive вызовется конструктор без параметров. tt = 89.
	MasHolder mash; // У Massive вызовется конструктор без параметров. Переменные не инициализированы.
	Book book = { BN(23, 68.0f), 56 };
	BN bn = { 45, 67.0f }; // Конструторы копирования и перемещения генерируются автоматически в случае отсутствия.
	BCInh bci{};
	BN* pbn = new BN[2]{ BN(1,2.0f), BN(5,6.7f) }; // Если заявленное количество не будет соответствовать или будет написано "()" в конце, то будет ошибка, что нет конструктора по умолчанию.

	MassiveInit mi; // Все, кроме i, не будут инициализированы вне зависимости от уровня доступа.
	MassiveInit mp{}; // Результат тот же, что и вверху.
	MassiveInit mc = MassiveInit(); // Результат тот же, что и вверху.
	//MassiveInit ms(); // Пустой.

	MassiveInit1 ms; // i = 90; Остальные неинициализированы. В этом случае отдельно инициализировать ничего нельзя.
	MassiveInit1 md{}; // ВСЕ инициализированы.
	MassiveInit1 mw = MassiveInit1(); // ВСЕ инициализированы.

	auto* mi1 = new MassiveInit;   // Все, кроме i, не будут инициализированы вне зависимости от уровня доступа.
	auto* mp1 = new MassiveInit{}; // Результат тот же, что и вверху.
	auto* mc1 = new MassiveInit(); // Результат тот же, что и вверху.

	auto* ms1 = new MassiveInit1;   // i = 90; Остальные неинициализированы.
	auto* md1 = new MassiveInit1{}; // ВСЕ инициализированы.
	auto* mw1 = new MassiveInit1(); // ВСЕ инициализированы.

	delete mi1;
	delete mp1;
	delete mc1;
	delete ms1;
	delete md1;
	delete mw1;

	int mas[2]; // Не будет инициализирован.

	int t1 = Mas1[0];
	int t2 = Mas1[1];
	int t3 = Mas2[0];
	int t4 = Mas2[1];

	int *k = Mas1, *m = Mas2;
	auto km = m - k; // int
	int p = k[-2]; // Номер индекса - тип со знаком (int).
	const auto t = static_cast<size_t>(-2);
	int s = Mas1[t]; // Тип всё равно со знаком (int).
	const unsigned long long g = 12;
	int o = Mas1[g]; // Превращается в беззнаковый (g). Таким образом, можно задать беззнаковый и очень большой индекс.
	int ty = 90;
	int f = Mas1[static_cast<unsigned long long>(ty)]; // Тип со знаком или без знака, в зависимости от поданного.
	const unsigned int w = 3;
	int n = Mas1[w]; // Тип со знаком.
	int j = Mas1[-1]; // Тип со знаком.
	int r = Mas2[1]; // Тип со знаком.

	DF* lk = nullptr;
	lk->Void();
	DF* pdf = new DF();
	pdf->Void();
	int* pi = reinterpret_cast<int*>(pdf); // 90.
	int* gi = new int{ 12 }; // Если нет скобок, то нет инициализации, а если () или {}, то она есть. Если в {} поставить число, то им будет инициализирована переменная, но при этом нельзя перечислять их через запятую.
	int* gi1 = new int(9); // Переменная равна 9.
	double* pd = new double[10](); // если в конце "()", то будет инициализация нулями. "()" нельзя написать, если нет конструктора по умолчанию.

	DG dg[3] = { {12} }; // Первый равен 12, остальные нолю.
	DG dh[3]{ {13} }; // Первый равен 13, остальные нолю.
	DG dp[3]{ 14 }; // Первый равен 14, остальные нолю, но так лучше не писать.
	DG dй[3] = { 15 }; // Первый равен 15, остальные нолю, но так лучше не писать.
	DG dk{ 10 }; // Нормально.

	DG* pdg = new DG{ 14 }; // Взято из книги Страуструпа.
	DS* pds = new DS{ 12.2f, 13 };
	DS* pdp = new DS(12.2f, 13); // Инициализирован.
	DG* plg = new DG(); // Инициализирован.
	DG* gpl = new DG; // Не инициализирован.
	DG* gph = new DG{}; // Инициализирован.

	size_t count = 2;
	// DG dgx[count]; // count может быть только константой.
	DG* pph = new DG[count]; // Не инициализирован.
	DG* kkp = new DG[count](); // Инициализирован.
	DG* kkm = new DG[count]{}; // Инициализирован.
	DG* kvp = new DG[count]{ 112, 113 }; // Ошибки не будет, но инициализации тоже. Нельзя так писать. Знак "=" перед "{" ставить нельзя. СТРАННО: дело в том, что переменная "count" учитывается, т.е. размер передаётся в оператор new, но далее инициализатор игнорируется.
	DG* kvk = new DG[count]{ DG(), {113} }; // Ошибки не будет, но инициализации тоже. Нельзя так писать. Знак "=" перед "{" ставить нельзя. СТРАННО: дело в том, что переменная "count" учитывается, т.е. размер передаётся в оператор new, но далее инициализатор игнорируется.
	DG* kvq = new DG[count]{ {112}, {113} }; // Ошибки не будет, но инициализации тоже. Нельзя так писать. Знак "=" перед "{" ставить нельзя. СТРАННО: дело в том, что переменная "count" учитывается, т.е. размер передаётся в оператор new, но далее инициализатор игнорируется.
	//DS* pd2 = new DS[2]{ {12.2f, 13}, {13.3f, 14} }; // Иначе нельзя. "t1" не инициализирована. count подставить нельзя. Пойдёт только константа.

	DG* kph = new DG[10]; // Не инициализирован.
	DG* vkp = new DG[10](); // Инициализирован.
	DG* vkm = new DG[10]{}; // Инициализирован.
	DG* vvp = new DG[10]{ 112, 113 }; // Ошибки не будет, но инициализации тоже. Нельзя так писать.
	DG* vvm = new DG[10]{ {112}, {113} }; // Ошибки не будет, но инициализации тоже. Нельзя так писать. Знак "=" перед "{" ставить нельзя.
	DG* vvk = new DG[10]{ DG(), {113} }; // Ошибки не будет, но инициализации тоже. Нельзя так писать.
	DG* vvq = new DG[2]{ {112}, {113} }; // Ошибки не будет, но инициализации тоже. Нельзя так писать. Знак "=" перед "{" ставить нельзя.
	DS* kd2 = new DS[2]{ {12.2f, 13}, {13.3f, 14} }; // Иначе нельзя. "t1" не инициализирована.

	// DS* zph = new DS; // Нет конструктора по умолчанию.
	// DS* mph = new DS[10]; // Нет конструктора по умолчанию.

	DS pdn{ 12.4,34 }; // Нормально.
	DS pdz(12.4, 34); // Нормально.
	// DG dgf(); // Ошибка.
	// DS* zpm = new DS(); // Ошибка.
	DG dfg{ 10 }; // Нормально.
	DG mdg; // Не будет инициализировано.
	DG sdg{}; // Инициализация по умолчанию.

	DS dc[3] = { {16,6}, {17,7}, {18,8} }; // Если написать меньше, чем указано в инициализаторе, будет ошибка из-за отсутствия конструктора по умолчанию.

	double x{ 2.7 };
	// int y1 {x};   // Ошибка.
	// int y1 = {x}; // Ошибка.
	int y3 = x; // Так лучше не писать.
	int y4 = static_cast<int>(x); // Так надо писать.
	double tre[5]{ 1.1, 2.2 }; // Будут инициализированы первые два заданными значениями, остальные нулями.
	double trr[5] = { 3.3, 4.4 }; // Будут инициализированы первые два заданными значениями, остальные нулями.

	int df = 12.2;
	double d1 = 12.5;
	int i = d1;
	char* a = "1";

	IniSeq seq;

	DoubleInit di; // i = 20
	DoubleInit da(3.14f); // i = 30. () писать нельзя. Получается так, что i никогда не будет равна 19.
	DoubleInit dx{}; // i = 20
}