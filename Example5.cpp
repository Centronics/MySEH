#include "Example5.h"

TestClass4::TestClass4()
{
	Mas = nullptr;
	Mas = new char[536870912];
	Value = 0;
}

TestClass4::~TestClass4()
{
	delete Mas;
	Mas = nullptr;
	if (!Value)
	{
		//*(int*)0 = 0;//если модель обработки исключений не используется ("НЕТ") то это исключение заставит систему вызвать деструктор объекта ert
		throw 0;//если модель обработки исключений не используется ("НЕТ") то это исключение "сорвет" вызов
		//деструкторов объектов tst и ert даже не смотря на то, что ert относится к другому обработчику
		//если модель обработки исключений используется, то все деструкторы будут выполнены и исключение будет брошено
		//последующему обработчику после текущего
	}
	Value = 2;
}

void Example5()
{
	try
	{
		TestClass4 ert;
		ert.Value = 15;
		try
		{
			throw ert;
		}
		catch(TestClass4 tst) //создается копия объекта
		{
			tst.Value = 6;//подводный камень: происходит передача объекта с созданием его копии, соответственно,
			//получится так, что деструктор будет вызван два раза для, казалось бы, двух разных объектов
			//однако, область памяти, созданная с помощью оператора new будет удалена два раза
			TestClass4 tst1;
		}
	}//если происходит какое-либо исключение: аппаратное или программное не того типа, что может быть перехвачено
	//предыдущим обработчиком, то сработает этот
	catch(int i)
	{
		__asm nop;
	}
}